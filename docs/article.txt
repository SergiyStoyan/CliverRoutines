<h2>Introduction</h2>

<p>CliverRoutines is a cross-platform C# lib which provides the frequently needed routines:</p>

<p><br />
- application settings manager which supersedes .NET ConfigurationManager;<br />
- logger with threading and session support;<br />
- auxiliary routines;</p>

<p>CliverRoutines has been developed on .NET Standard 2.0 and supposed to run on any platform supported by .NET Core, Xamarin or Mono.</p>

<p>This article is a brief&nbsp;overview. For details refer to <a href="https://sergeystoyan.github.io/CliverRoutines/#1">the documentation</a>.</p>

<h2>Background</h2>

<p>Every time I was using .NET ConfigurationManager&nbsp;it was a pain when I needed to store a custom type settings. Not to mention editing settings&nbsp;though Visual Studio settings table which was terribly unhandy. And not to mention&nbsp;the case when you need to override certain settings. In general, to make ConfigurationManager do&nbsp;something special,&nbsp;forced&nbsp;into&nbsp;awkward coding.</p>

<p>That&#39;s why years ago I developed my own settings manager <code>Cliver.Config</code>. The idea&nbsp;behind it appeared so apt that I&nbsp;have&nbsp;never looked back since then. It has been&nbsp;used in apps of any complexity on Winows and Xamarin.Mac and proved to be simple in use,&nbsp;flexible and&nbsp;robust.</p>

<p>Also CliverRoutines lib provides a logger and auxiliary routines.</p>

<h2>Config</h2>

<p><a href="#_localAnchor_config"><code>Cliver.Config</code></a>&nbsp;is a cross-platform replacement for .NET ConfigurationManager. It is highly intuitive and simple in use, and yet versatile and powerful. Its features:</p>

<p>- supports any C# platform;</p>

<p>- natively enables setting&nbsp;types of any complexity and functionality;</p>

<p>- settings are easily modified and&nbsp;set directly in&nbsp;code&nbsp;;</p>

<p>- enables settings&nbsp;polymorphism;</p>

<p>- is thread-safe;</p>

<p>- serializes data&nbsp;into JSON;</p>

<p><b>Idea:</b></p>

<p>Settings are ordinary C# classes that you define in your code&nbsp;according to your needs thus achieving a great flexibility.&nbsp;<code>Cliver.Config</code>&nbsp;automatically detects&nbsp;settings fields/properties&nbsp;in your code and facilitates their serialization/deserialization on disk.</p>

<p>While&nbsp;<code>Cliver.Config</code>&nbsp;was designed primarily as a settings manager, in conjunction with&nbsp;<code>System.Linq</code>&nbsp;it can be used as a simple nosql database.</p>

<p>&nbsp;</p>

<h3>Usage example</h3>

<p>Reference CliverRoutines in your project.<br />
Set your project&#39;s company name as it defines the storage directory.</p>

<p>Define a&nbsp;settings type&nbsp;according to your needs. Generally a settings type is an ordinary class which inherits&nbsp;<code>Cliver.Settings</code>&nbsp;or one of its derivatives, e.g.&nbsp;<code>Cliver.UserSettings</code>.&nbsp;Serializable values must be exposed by <code>public</code> fields or properties.&nbsp;</p>

<p>See this one:</p>

<pre lang="cs">
<code>//settings type
public class GeneralSettings : Cliver.UserSettings //it is serialized to the user data directory
{
	public int Host;
	public int Port = 25;
	public List&lt;Client&gt; Clients = new List&lt;Client&gt;();
}

public class Client
{
	public string Name;
	public string Email;
}</code></pre>

<p>Somewhere, declare a&nbsp;settings field or property of the defined&nbsp;settings type:</p>

<pre lang="cs">
<code>public class Settings
{
	public static readonly GeneralSettings General;//readonly is optional. It can be a property.
}
</code></pre>

<p>At the beginning of the application, add initializing:</p>

<pre lang="cs">
<code>
//optional configuration must be done before initializing settings. See the API and annotations for options.
...

//detect and initialize settings fields. It can be called multiple times where every call re-initializes settings.
Cliver.Config.Reload();//!!!mandatory call before using settings 
</code>
</pre>

<p>Now settings are ready to be used:</p>

<pre lang="cs">
<code>
//modify
Settings.General.Host = &quot;smtp.server.com&quot;;
Settings.General.Clients.Add(new Client {Name = &quot;Tom&quot;, Email = &quot;tom@company.com&quot;});
...
//save on disk
Settings.General.Save();
//or, restore the previous values instead of saving the new ones
Cliver.Config.Reload();
//or, reset to the initial values
Cliver.Config.Reset();
...
//pass to a function
notify(Settings.General.Host, Settings.General.Port, Settings.General.Clients);
</code>
</pre>

<p>To see live usage examples, refer to CliverRoutinesExample project in CliverRoutines solution.<br />
For the complete usage options, review&nbsp;<code>Cliver.Config</code>&nbsp;API and annotations.</p>

<h2>Log</h2>

<p><a href="#_localAnchor_log"><code>Cliver.Log</code></a>&nbsp;features:</p>

<p>- cross-platform;</p>

<p>- thread-safe;</p>

<p>- session oriented. It means that an application can write multiple log sessions successively or simultaneously. It is helpful when an application performs multiple independent tasks;</p>

<p>- thread oriented. It means it can&nbsp;write log&nbsp;per thread;</p>

<p>- auto-cleanup of old logs.</p>

<h3>Usage example</h3>

<p>Trivial logging when everything is written to the same file:</p>

<pre lang="cs">
<code lang="cs">using Cliver;
...


Log.Inform(&quot;test message&quot;);</code></pre>

<p>Logging to a named log of an explicitly created&nbsp;<a href="#_localAnchor_log_session">session</a>:</p>

<pre lang="cs">
<code>//writing to the session &quot;Game1&quot;
Log.Session game1Session = Log.Session.Get(&quot;Game1&quot;);

//to the main log
game1Session.Inform(&quot;test message&quot;);

//to the log named &quot;Test&quot;
game1Session[&quot;Test&quot;].Inform(&quot;test message&quot;);
</code></pre>

<p>In this example, each&nbsp;thread writes its own log:</p>

<pre lang="cs">
<code>using Cliver;
...

static void download(string uri)
{
	try
	{
		//each download thread writes its own log in the default (Head) session
		Log.Thread.Inform(&quot;test message&quot;); //It is a shortcut for Log.Head.Thread.Inform()
	}
	catch (Exception e)
	{
		Log.Thread.Error2(e);
	}
}

static void Main(string[] args)
{
	//launch a number of parallel theads
	ThreadRoutines.Start(() =&gt; { download(&quot;http://file.com/1&quot;); });
	...
	ThreadRoutines.Start(() =&gt; { download(&quot;http://file.com/N&quot;); });
}
</code></pre>

<h2>Using the code</h2>

<p>A brief description of how to use the article or code. The class names, the methods and properties, any tricks or tips.</p>

<p>Blocks of code should be set as style &quot;Formatted&quot; like this:</p>

<pre lang="cs">
//
// Any source code blocks look like this
class fg
{
}  
//
</pre>

<h2>History</h2>

<p>Keep a running update of any changes or improvements you&#39;ve made here.</p>
