<html>
<head>
    <title>CliverRoutines</title>

    <link rel="stylesheet" type="text/css" href="main.css">
    <link rel="stylesheet" type="text/css" href="menu_generator.css">

    <link href="prism.css" rel="stylesheet" />

</head>
<body>
    <script src="prism.js"></script>
    <div class='header'>
        <div class='mainHeader'>CliverRoutines 5.*</div>
    </div>

    <div class='content'>
        <h1><a name='overview'>Overview</a></h1>
        <p> CliverRoutines is a cross-platform C# lib which provides the frequently needed routines:

 <ul>
                <li> <a href="#config">application settings module</a> which supersedes the one provided by Visual Studio;</li>
                <li> <a href="#log">logger</a> with multi-threading and <a href='#log_session'>session</a> support;</li>
                <li> <a href="#miscellaneous">auxiliary routines</a>;</li>
            </ul>
			
<p><b>Compatibility</b>
<br>CliverRoutines has been developed on .NET Standard 2.0 and supposed to run on any platform supported by .NET Core, Xamarin or Mono. 			
<br>A possible concern about certain platform might be regarded to peculiarities of the platform's file system.

			<p>CliverRoutines has been used on:
<br> - Windows 7, 10 in C# projects of any configuration built in Visual Studio;
<br> - macOS High Sierra 10.12 in Xamarin.Mac projects built in Visual Studio for Mac;


            <h2><a name='licensing'>Licensing</a></h2>
			
			  Open <a href='https://raw.githubusercontent.com/sergeystoyan/CliverRoutines/master/LICENSE' target='_blank'>license</a>
			<br><br><br>
			<textarea id="license" rows="30" cols="100">
           
</textarea>
<script>
function setLicense() {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'https://raw.githubusercontent.com/sergeystoyan/CliverRoutines/master/LICENSE');
    xhr.send(null);

    xhr.onreadystatechange = function () {
        var status = 4;
        var http_code = 200;
        if (xhr.readyState === status) {
            if (xhr.status === http_code)  {
                var textarea = document.getElementById('license');
                textarea.value = xhr.responseText;
            } else {
                // do something with an error here
            }
        } 
    }
};

setLicense();
</script>

            <h2><a name='licensing'>Source code</a></h2>
            Open <a href='https://github.com/sergeystoyan/CliverRoutines' target='_blank'>repository</a>
        <p>
            Do not download the latest code from a branch because it may be under development. Instead, use the latest (pre-)release code.




            <h1><a name='config'>Config</a></h1>
<a href='#config'><code>Cliver.Config</code></a> is a cross-platform replacement for Visual Studio standard applications settings module. It is very simple in use while versatile and powerful.

<p><b>Idea:</b> <a href='#config'><code>Cliver.Config</code></a> automatically detects <a href='#settings_field'>settings fields/properties</a> in your code and facilitates their serialization/deserialization on disk.


<p>You define <a href='#settings_class'>types</a> of <a href='#settings_field'>settings fields</a> according to your needs thus achieving a great flexibility.
        <p>While <a href='#config'><code>Cliver.Config</code></a> was designed primarily as a settings engine, in conjunction with <code>System.Linq</code> it can be used as a simple nosql database.
        <p>
            <a href='#config'><code>Cliver.Config</code></a> is thread-safe.
			
			<p>To see live usage examples, refer to CliverRoutinesExample project.
			
			
			
			

            <h2><a name='settings_class'>Settings type</a></h2>
			<a href='#settings_class'>Settings type</a> is a custom class that is to be serialized/deserialized according to the needs of the application. To be recognized as such, it must inherit <a href='#cliver_settings'><code>Cliver.Settings</code></a> class.
			
			<p>While a settings class is primarily a collection of settings, yet in general it should be considered a fully functional class which is enhanced with serializing/deserializing of its fields/properties. 
			
<p>(!)Fields/properies of a settings class must be <code>public</code> and <code>non-static</code> to be considered serializable by <a href='#config'><code>Cliver.Config</code></a>. 

			<p>There can be any number of settings types defined in your code.
			

<h3>Newtonsoft.Json</h3>
			<br>Serialization/deserialization is performed by <a href='https://www.newtonsoft.com/json'>Newtonsoft.Json</a> engine.
Hence you can apply attributes provided by <code>Newtonsoft.Json</code> to certain fields/properties of a <a href='#settings_class'>settings class</a> to alter their serialization behaviour. To do so, you have to reference <code>Newtonsoft.Json</code> in your project. (To avoid compilation problems, make sure that it is the same version that is referenced by CliverRoutines.) For more info refer to <a href='https://www.newtonsoft.com/json'>Newtonsoft.Json</a> documentation. 			
			
<p>(!)While a <a href='#settings_class'>settings class</a> can implement any logic and members, remember that nevertheless there are restrictions for what and how can be serialized. For instance, data which depend on the current application state like <code>events, FieldInfo</code> types will be lost through serialization.

						
            <h3><a name='cliver_settings'>Cliver.Settings</a></h3>
			<a href='#cliver_settings'><code>Cliver.Settings</code></a> is a base <a href='#settings_class'>settings type</a> defined in <a href='#config'><code>Cliver.Config</code></a>.
<p>It exposes some members that allow managing serialization routine in its derivatives:
<br> - property <code>__Info</code> which links <a href='#settings_class'>a settings type</a> to a certain <a href='#settings_field'>settings field</a>;
<br> - auxiliary methods some of which can be redefined in your settings class if needed;
<br>See API and annotations for more info.

        <p>			Usually you will not inherit <a href='#cliver_settings'><code>Cliver.Settings</code></a> directly and use one of its derivatives provided by CliverRoutines: <a href="#cliver_usersettings"><code>Cliver.UserSettings</code></a> and <a href="#cliver_appsettings"><code>Cliver.AppSettings</code></a>.
			<br>If your <a href='#settings_class'>settings class</a> inherits <a href='#cliver_settings'><code>Cliver.Settings</code></a> directly then you have to define the serialization directory in it.



            <h4><a name="cliver_usersettings">Cliver.UserSettings</a></h4>
<a href="#cliver_usersettings"><code>Cliver.UserSettings</code></a> is a <a href='#cliver_settings'><code>Cliver.Settings</code></a> derivative which provides serialization to the current user's application data directory. 




            <h4><a name="cliver_appsettings">Cliver.AppSettings</a></h4>
<a href="#cliver_appsettings"><code>Cliver.AppSettings</code></a> is a <a href='#cliver_settings'><code>Cliver.Settings</code></a> derivative which provides serialization to the common (user-irrelevant) application data directory. 
<p>(!)Writing to this directory on Windows may require additional permissions which is solved by <code>Cliver.Win.AppSettings</code> in CliverWinRoutines package.

				    
				   

			
<h3>Example</h3>
			
<pre>
<code class="language-csharp">
//define a settings class which is serialized to the user data directory.
public class GeneralSettings : Cliver.UserSettings
{   	
	public List&lt;string&gt; Files; 	
	public string Host = "";
	public int Port = 123;
	
	protected override void Loaded()
	{
		if(Files == null)
			Files = new List<string>(); 
	}
	
	protected override void Saving()
	{
		Files = Files.Distinct();
	}
}
</code>
</pre>

			

			


			
<h2><a name='settings_field'>Settings field</a></h2>
			<a href='#settings_field'>Settings field</a> is a field or property of <a href='#settings_class'>settings type</a> declared in any class of your app. 
			<p>(!)A <a href='#settings_field'>settings field</a> must be <code>static public</code> to be processed by <a href='#config'><code>Cliver.Config</code></a>. Such fields are automatically detected by <a href='#config'><code>Cliver.Config</code></a> and can be serialized/deserialized.
			
			<p>There can be any number of <a href='#settings_field'>settings field</a>s in your code.
                   Usually you will need only one <a href='#settings_field'>settings field</a> per <a href='#settings_class'>settings type</a> but there is no problem to declare any number of <a href='#settings_field'>settings fields</a> of the same <a href='#settings_class'>settings type</a>.
				   				


			
			  
		   <p>  At the outset <a href='#settings_field'>settings fields</a> are initialized by <a href='#config'><code>Cliver.Config</code></a> which creates instances of their <a href='#settings_class'>settings types</a>. <br>But you too can create or clone instances of <a href='#settings_class'>settings types</a>. And if a <a href='#settings_field'>settings field</a> is non-readonly, you can replace its value with another instance. 
<br>An instance of <a href='#settings_class'>settings type</a> which is the value of some <a href='#settings_field'>settings field</a> is called <i>attached</i>, otherwise, <i>detached</i>. See <a href='#swapping_settings'>example</a>.



								
				   
<h3>Example</h3>
<pre>
<code class="language-csharp">
//create a field of GeneralSettings type anywhere in the code. 
namespace App
{
	public class Settings
	{
		//Usually, to avoid mess, you'd like to make it readonly. But it is optional because sometimes the logic of the app may require replacing the value.
		public static readonly GeneralSettings General;
	}
}
</code>
</pre>
		
<h3>Initialization</h3>
        <br> Detection and initialization of <a href='#settings_field'>settings field</a>s must be triggered from your code. It can be preceded by optional configuration of <a href='#config'><code>Cliver.Config</code></a> (see its API).
<pre>
<code class="language-csharp">
//configure. It must be done before initializing the settings.
Cliver.Config.ExplicitlyTrackedAssemblies = new List<System.Reflection.Assembly> { Assembly.GetExecutingAssembly() };//optional

//detect and initialize settings fields. 
Cliver.Config.Reload();//mandatory
</code>
</pre>			   
				
				
				
				
<h3>Assembly scope</h3>
        <br>(!)When looking for <a href='#settings_field'>settings fields</a> in an application, <a href='#config'><code>Cliver.Config</code></a> searches within the following assemblies by default:
<br> - assembly that calls one of <a href='#config'><code>Cliver.Config</code></a>'s initializing methods;
<br> - assemblies that are referenced by the calling assembly;
<br>The search scope is limited this way in order not to load more assemblies which is necessary while enumerating through them. 
 
<p>If needed, the assembly scope can by assigned from code explicitly (see the API).
			
			
				   
				   
			
			
			
<h3><a name='storage_file'>Storage file</a></h3>
		<a href='#storage_file'>Storage file</a> stores serialized data for one <a href='#settings_field'>settings field</a>. Thus, each <a href='#settings_field'>settings field</a> has its own <a href='#storage_file'>storage file</a>. 
		
		<p>It is re-created by call of <code>Save()</code> on a <a href='#settings_field'>settings field</a>.
			
			
			
			<h4>Path</h4>
			<p><a href='#storage_file'>Storage file</a> path is defined as follows: file directory is predetermined by the <a href='#settings_class'>settings type</a> and file name is predetermined by the <a href='#settings_field'>settings field</a>'s full path in the code.
									
<p>See the example:
<pre>
<code class="language-csharp">
namespace App
{
	public class GeneralSettings : Cliver.UserSettings
	{   	
		public string User;
	}
	
	public class Settings
	{
		public static readonly GeneralSettings General;
	}
}
</code>
</pre>
The <a href='#storage_file'>storage file</a> path of <a href='#settings_field'>settings field</a> <code>Settings.General</code> will be:
			<table style="table-layout:fixed;">
			<tr>
			<td style="border:0;">storage file path:</td>
			<td bgcolor="#ddf" style="margin:0;padding:0;border:0;border-collapse:collapse;">C:\Users\serge\AppData\Local\</td>
			<td bgcolor="#def" style="margin:0;padding:0;border:0;border-collapse:collapse;">SuperDuperSoft\App\config\</td>
			<td bgcolor="#dff" style="margin:0;padding:0;border:0;border-collapse:collapse;">App.Settings.General.json</td>
				</tr>
				<tr>
			<td>predetermined by:</td>
			<td style="width:10px;"><code>Cliver.UserSettings</code></td>
			<td style="width:10px;">application's name 'App' and company name 'SuperDuperSoft'</td>
			<td style="width:10px;">the full path of field <code>General</code> in the application</td>
			</tr>
			</table>
			





			
			
<h3><a name='initial_file'>Initial file</a></h3>
			<p><a href='#initial_file'>Initial file</a> keeps data which supersede the initial values hardcoded in the <a href='#settings_class'>settings type</a> definition. Each <a href='#settings_field'>settings field</a> can have its own <a href='#initial_file'>initial file</a> and thus, can have its own initial value set. 
			
			<p>It is optional and has the same format as <a href='#storage_file'>storage file</a>.
			
		<p><a href='#initial_file'>Initial file</a> is re-read by call of <code>Reload()</code> or <code>Reset()</code>.
			
			<p>It is supplied in the same directory as the application itself.
		 
			
			<p>It is helpful when:
			<br> - initial settings data are too big to be kept in code;
			<br> - initial settings data can be more easily managed in file, not in code;
			<br> - the application has several <a href='#settings_field'>settings fields</a> of the same <a href='#settings_class'>settings type</a> and each of them must be initiated by its own value set;
						
			
			
			<h4>Name</h4>
			<p><a href='#initial_file'>Initial file</a> name is predetermined by the <a href='#settings_field'>settings field</a>'s full path in the code.
									
<p>See the example:
<pre>
<code class="language-csharp">
namespace App
{	
	public class Settings
	{
		public static readonly GeneralSettings General;
	}
}
</code>
</pre>
The <a href='#initial_file'>initial file</a> name of <a href='#settings_field'>settings field</a> <code>Settings.General</code> will be 'App.Settings.General.json'.



			
			
<h3>Restoring order</h3>
            <br><a href='#config'><code>Cliver.Config</code></a> performs restoring of a <a href='#settings_field'>settings field</a> in the following order:
			
			<p><code><b>Reload()</code></b>
			<br> - from one's <a href='#storage_file'>storage file</a> if exists;
			<br> - from one's <a href='#initial_file'>initial file</a> if exists;
			<br> - from the values predefined in one's <a href='#settings_class'>settings type</a>;
		
			<p><code><b>Reset()</code></b>
			<br> - from one's <a href='#initial_file'>initial file</a> if exists;
			<br> - from the values predefined in one's <a href='#settings_class'>settings type</a>;
		




<h2><a name=''>Usage</a></h2>
			Reference CliverRoutines in your project.
			
			
					
			<p>Define a <a href='#settings_class'>settings type</a> according to your needs like this one:		
<pre>
<code class="language-csharp">
//settings type
public class GeneralSettings : Cliver.UserSettings //it is serialized to the user data directory
{
	public int SmtpHost;
	public int SmtpPort = 25;
	public List&lt;Client&gt; Clients = new List&lt;Client&gt;();
}

public class Client
{
	public string Name;
	public string Email;
}
</code>
</pre>
			
			
			<p>Somewhere, declare a <a href='#settings_field'>settings field</a> of the defined <a href='#settings_class'>settings type</a>:			
			<pre>
<code class="language-csharp">
public class Settings
{
	public static readonly GeneralSettings General;//readonly is optional. It can be a property.
}
</code>
</pre>


        <p> At the beginning of the application, add initializing:
<pre>
<code class="language-csharp">
//optional configuration must be done before initializing settings. See the API and annotations for options.
...

//detect and initialize <a href='#settings_field'>settings fields</a>. It can be called many times where every call re-initializes settings.
Cliver.Config.Reload();//!!!mandatory call before using settings 
</code>
</pre>


         <p>      Now settings are ready to be used:
<pre>
<code class="language-csharp">
//modify
Settings.General.SmtpHost = "smtp.server.com";
Settings.General.Clients.Add(new Client {Name = "Tom", Email = "tom@company.com"});
...
//save on disk
Settings.General.Save();
//or, restore the previous values instead of saving the new ones
Cliver.Config.Reload();
//or, reset to the initial values
Cliver.Config.Reset();
...
//pass to a function
notify(Settings.General.SmtpHost, Settings.General.SmtpPort, Settings.General.Clients);
</code>
</pre>
         <p>See <a href='#config'><code>Cliver.Config</code></a> API and CliverRoutinesExample project for more options.
		 
            <h2><a name=''>Tips</a></h2>

            <h3><a name='restoring_predefined_collections'>(!)Predefining collections</a></h3>
			
			Pay attention that when you predefine a collection of values in your code, it will be doubled every time when it is saved/restored. It is how Newtonsoft.Json works by default.
			<br>To alter this behaviour, add the attribute as in the example below:

<pre>
<code class="language-csharp">
public class GeneralSettings : Cliver.UserSettings
{   	
	//avoid doubling the collection's elements
	[JsonProperty(ObjectCreationHandling = ObjectCreationHandling.Replace)]
	public List&lt;string&gt; Options = new List&lt;string&gt;("apple", "pear", "banana"); 
}
</code>
</pre>
			
			
            <h3><a name=''>Ignoring fields/properties</a></h3>

            To make a certain field or property not serializable, make it <code>non-public</code>. Otherwise, reference <code>Newtonsoft.Json</code> and add the attribute as in the example:
<pre>
<code class="language-csharp">
public class GeneralSettings : Cliver.UserSettings
{   	
	//this field will not be serialized
	internal string Password; 
	
	//this field will not be serialized
	[Newtonsoft.Json.JsonIgnore]
	public string Password2;
}
</code>
</pre>	





            <h3><a name='swapping_settings'>Cloning and replacing</a></h3>

            Sometimes it is handy to modify not a <a href='#settings_field'>settings field</a> itself but its clone and then replace it:
<pre>
<code class="language-csharp">
//create a clone
GeneralSettings general2 = Settings.General.CreateClone();//!!!property __Info is not cloned but references the same object.

//modify
general2.ClientPort = 123;

if(userOk())
{
	Settings.General = general2;
	Settings.General.Save();
}
</code>
</pre>






            <h3><a name=''>Polymorphism</a></h3>
Being ordinary C# classes, <a href='#settings_class'>settings types</a> support polymorphism. That is, you can build many <a href='#settings_class'>settings types</a> inheriting the same parent and easily switch between them depending on the application logic. See the example.

<p>Define a base <a href='#settings_class'>settings type</a> and its derivatives:
<pre>
<code class="language-csharp">
//base settings class which you will reference in your code
abstract public class ScopeSettings : Cliver.UserSettings
{
	virtual public string HelpUri { get; set; }

	public static ScopeSettings Scope { get; internal set; }//(!)it is ignored by Cliver.Config because ScopeSettings is abstract class
}

//derivative1 implementing certain logic
public class Scope1Settings : ScopeSettings
{
	override public string HelpUri { get; set; } = "http://www.help.com/help1.html";

	public static Scope1Settings This;//a settings field can be nested in its own settings type
}

//derivative2 implementing certain logic
public class Scope2Settings : ScopeSettings
{
	override public string HelpUri { get; set; } = "http://www.help.com/help2.html";

	public static Scope2Settings This;
}
</code>
</pre>

<p>Initialize <a href='#settings_field'>settings fields</a> and set the required scope:
<pre>
<code class="language-csharp">
Config.Reload();
//choose which scope to use?
ScopeSettings.Scope = Scope1Settings.This;
</code>
</pre>

<p>Now, independing on the actual scope, you can use <code>ScopeSettings.Scope</code> uniformly:
<pre>
<code class="language-csharp">
...
Process.Start(ScopeSettings.Scope.HelpUri);
...
ScopeSettings.Scope.HelpUri = "http://www.help.com/help3.html"; 
ScopeSettings.Scope.Save();
</code>
</pre>






            <h3><a name='storing_password'>Storing password</a></h3>
            How to store and use passwords:
<pre>
<code class="language-csharp">
public class GeneralSettings : Cliver.Win.UserSettings
{   	            
	//password will be stored on disk as an ecrypted string
	public string _EncryptedPassword = null;
	
	//it is internal so not to be serialized; otheriwse if public, use attribute [Newtonsoft.Json.JsonIgnore]
	internal string Password
	{
		get
		{
			if (string.IsNullOrEmpty(_EncryptedPassword))
				return null;
			try
			{
				return crypto.Decrypt(_EncryptedPassword);
			}
			catch(Exception e)
			{
				Cliver.Log.Error("Could not decrypt password.", e);
				return null;
			}
		}
		set
		{
			if (string.IsNullOrEmpty(value))
				_EncryptedPassword = null;
			else
				_EncryptedPassword = crypto.Encrypt(value);
		}
	}
	//on Widnows
    Cliver.Win.Crypto.ProtectedData crypto = new Cliver.Win.Crypto.ProtectedData();
	//cross-platform
    Cliver.Crypto.Rijndael crypto = new Cliver.Crypto.Rijndael("random key");
}

public class Settings
{
	public static readonly GeneralSettings General;
}
</code>
</pre>

<p>Now, use it anywhere in the code:
<pre>
<code class="language-csharp">
Settings.General.Password = password;
Settings.General.Save();

...
connect(General.Password);
</code>
</pre>







            <h3><a name=''>Passing to another process</a></h3>
You can pass a <a href='#settings_field'>settings field</a> to another process. It should be done through serialization.

<p>In process 1:
<pre>
<code class="language-csharp">
string generalStr = Cliver.Serialization.Json.Serialize(Settings.General);

//pass generalStr to process 2...
</code>
</pre>

<p>In process 2:
<pre>
<code class="language-csharp">
//restore
GeneralSettings general = Cliver.Serialization.Json.Deserialize(generalStr);
//modify
general.Files.Add("c:\\other.txt");
//serialize
generalStr = Cliver.Serialization.Json.Serialize(general);

//pass generalStr back to process 1...
</code>
</pre>

<p>In process 1:
<pre>
<code class="language-csharp">
//accept modifications
GeneralSettings general2 = Cliver.Serialization.Json.Deserialize(generalStr);
//!!!do not forget to restore __Info as it is distorted by serialization
general2.__Info = Settings.General.__Info;
Settings.General = general2;
Settings.General.Save();
</code>
</pre>





            <h1><a name='log'>Log</a></h1>
        <p>
            <a href='#log'><code>Cliver.Log</code></a> is a cross-platform logger. 
			
			<p>It is thread-safe.
			
			<p><a href='#log'><code>Cliver.Log</code></a> is <a href="#log_session">session</a> oriented. It means that an application can write multiple log <a href='#log_session'>sessions</a> successively or simultaneously.
            It is helpful when an application performs multiple independent tasks.
			
			<p>            <a href='#log'><code>Cliver.Log</code></a> supports <a href="#named_log">named</a> and <a href="#thread_log">thread</a> logs.
			
			<p> It performs auto-cleanup of old logs.
			
			
			<p>To see live usage examples, refer to CliverRoutinesExample project.
			



            <h2><a name='log_session'>Session</a></h2>

            Each log belongs to a <a href='#log_session'>session</a>. 
			<p>Depending on configuration, each <a href='#log_session'>session</a> can create its own folder so that all its logs are written there, otherwise, if all sessions must share the same folder, log files have their session name in their names.
			
            <p> Session folders can be used to store additional data like caches etc.
			
			<p> Multiple <a href='#log_session'>sessions</a> can be open simultaneously.
			
	<p>There is the default <a href='#log_session'>session</a> which has empty name and is referenced as <code>Head</code>.
			


			<h3><a name='log_default_session'>Head session</a></h3>
<a href='#log_default_session'>The default session</a> is a <a href='#log_session'>session</a> which is used when no <a href='#log_session'>session</a> is called explicitly. It is referenced as <code>Head</code> and has empty name.


<pre>
<code class="language-csharp">
using Cliver;
...
//write to the default session
Log.Write("message");// it is shortcut for Log.Head.Write("message");
</code>
</pre>



			<h3>Example</h3>
<pre>
<code class="language-csharp">
using Cliver;
...
//create or get an existing session
Log.Session game1Log = Log.Session.Get("Game1");
...
//write to the default log of the session
game1Log.Write("message");
...
//close all the file handlers beloning to the session.
game1Log.Close(true);//optional call to free memory
</code>
</pre>





			<h3><a name="#work_directory">Work directory</a></h3>
<br>
			All <a href='#log_session'>sessions</a> are created within the same <a href="work_directory">work directory</a> which is defined at the first log writing or call of <code>Log.Initialize()</code>
			
			
			<p>By default the <a href="work_directory">work directory</a> is defined in the order by which <a href='#log'><code>Cliver.Log</code></a> tries to write to:
			<br> - the folder where the application is located;
			<br> - the user data folder;
			<br> - the common data folder;
			<br> - the desktop folder;
			<br> - the temp folder;
			
			<p>The <a href="work_directory">work directory</a> definition can be customized while initializing:
<pre>
<code class="language-csharp">
//optional initialization before using logs
Log.Initialize(Log.Mode.FOLDER_PER_SESSION, new List<string> { Log.CompanyUserDataDir });//logs will be recorded to the user data folder
</code>
</pre>





    <h2><a name='named_log'>Named log</a></h2>
    <a href='#default_log'>Named log</a> is a log which can be referenced by custom name.
	<p>The name of a <a href='#default_log'>named log</a> is a part of its file name.




			<h3><a name='default_log'>Main log</a></h3>
<a href='#default_log'>The default log</a> of a <a href='#log_session'>session</a> is a <a href='#default_log'>named log</a> which is used when no <a href='#named_log'>named log</a> is called explicitly. It is referenced as <code>Main</code> and has empty name.

		
    <p><a href='#default_log'>The default log</a> is handy for trivial logging when everything is written to the same file:
<pre>
    <code class="language-csharp"> 
using Cliver;
...

//writing to the default (Main) log in the default (Head) session
Log.Inform("test message");//It is a shortcut for Log.Head.Main.Inform()

//writing to the default (Main) log of the session "Game1"
Log.Session game1Session = Log.Session.Get("Game1");
game1Session.Inform("test message");//It is a shortcut for game1Session.Main.Inform()
    </code>
</pre>



			<h3>Example</h3>

 <p>   Logging to a named log of <a href='#log_default_session'>the default session</a>:
<pre>
    <code class="language-csharp">
//writig to the log "Inform" of the default session
Log.Session.NamedWriter informLog = Log.Head["Inform"];
//writing to the log "Error" in the default session
Log.Session.NamedWriter errorLog = Log.Head["Error"];
try
{
	informLog.Inform("test message");
}
catch (Exception e)
{
	errorLog.Error2(e);
}
    </code>
</pre>

 <p>   Logging to a named log of an explicitly created <a href='#log_session'>session</a>:
<pre>
    <code class="language-csharp">
//writing to the session "Game1"
Log.Session game1Session = Log.Session.Get("Game1");

//to the main log
game1Session.Inform("test message");

//to the log named "Test"
game1Session["Test"].Inform("test message");
    </code>
</pre>





    <h2><a name='thread_log'>Thread log</a></h2>
    A <a href='#thread_log'>thread log</a> is a log that belongs to only one and the same .NET thread.
	<p>Each <a href='#thread_log'>thread log</a> has a unique ID which is a part of its file name. Depending on configuration, those ID's can be reused or be endlessly incremented for each new <a href='#thread_log'>thread log</a>.
	
	<p>In this example, each download thread writes its own log:
<pre>
<code class="language-csharp">
using Cliver;
...

static void download(string uri)
{
	try
	{
		//each download thread writes its own log in the default (Head) session
		Log.Thread.Inform("test message"); //It is a shortcut for Log.Head.Thread.Inform()
	}
	catch (Exception e)
	{
		Log.Thread.Error2(e);
	}
}

static void Main(string[] args)
{
	//launch a number of parallel theads
	ThreadRoutines.Start(() => { download("http://file.com/1"); });
	...
	ThreadRoutines.Start(() => { download("http://file.com/N"); });
}
</code>
</pre>




            <h2><a name='example'>Usage</a></h2>
			Reference CliverRoutines in your project.
			
		
        <p> At the beginning of the application, add optional initializing:
<pre>
<code class="language-csharp">
using Cliver;
...

//optional configuration can be done at the very beginning. See the API and annotations for options.
...

//optional initialization. It can be called many times where every call closes all the logs and re-initializes the engine.
Log.Initialize(Log.Mode.FOLDER_PER_SESSION); //this call is not mandatory if you are ok with default settings. 
</code>
</pre>


         <p>      Now the logger can be used:
<pre>
<code class="language-csharp">
Log.Inform("test message"); //trivial log usage
</code>
</pre> 
         <p>See <a href='#log'><code>Cliver.Log</code></a> API and CliverRoutinesExample project for more options.
		 
  






    <h1><a name='miscellaneous'>Miscellaneous</a></h1>
<p>CliverRoutines exposes a number of auxiliary routines. See the API and annotations.







    </div>

    <div class='footer'>
        <script src='copyright.js'></script>
        &nbsp;2006 - 2021&nbsp;&nbsp;<a href="javascript:window.location.href = '&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#115;&#101;&#114;&#103;&#101;&#121;&#46;&#115;&#116;&#111;&#121;&#97;&#110;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;'" target="_top">Sergey Stoyan</a>
       
    </div>

    <!--script>
    var cs = document.getElementsByTagName('code');
    for(var i = 0; i < cs.length; i++)
        cs[i].classList.add("language-csharp");
    </script-->

    <script>
        if (!window.location.href.match(/\#./ig)) {
            window.location.href = window.location.href.replace(/#.*/, '') + '#1';
            location.reload();
        }
    </script>
    <script src='menu_generator.js' shiftHeaderAndFooterToContentView=''></script>

</body>
</html>